{"version":3,"file":"component-store.js","sourceRoot":"ng://@ngrx/component-store/","sources":["src/component-store.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  isObservable,\n  Observable,\n  of,\n  ReplaySubject,\n  Subscription,\n  throwError,\n  combineLatest,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  takeUntil,\n  withLatestFrom,\n  map,\n  distinctUntilChanged,\n  shareReplay,\n} from 'rxjs/operators';\nimport { debounceSync } from './debounceSync';\n\n/**\n * Return type of the effect, that behaves differently based on whether the\n * argument is passed to the callback.\n */\ninterface EffectReturnFn<T> {\n  (): void;\n  (t: T | Observable<T>): Subscription;\n}\n\nexport class ComponentStore<T extends object> {\n  // Should be used only in ngOnDestroy.\n  private readonly destroySubject$ = new ReplaySubject<void>(1);\n  // Exposed to any extending Store to be used for the teardowns.\n  readonly destroy$ = this.destroySubject$.asObservable();\n\n  private readonly stateSubject$ = new ReplaySubject<T>(1);\n  private isInitialized = false;\n  // Needs to be after destroy$ is declared because it's used in select.\n  readonly state$: Observable<T> = this.select(s => s);\n\n  constructor(defaultState?: T) {\n    // State can be initialized either through constructor, or initState or\n    // setState.\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n  }\n\n  /** Completes all relevant Observable streams. */\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Everytime this function is called\n   *     subscribers will be notified of the state change.\n   */\n  updater<V>(\n    updaterFn: (state: T, value: V) => T\n  ): unknown extends V ? () => void : (t: V | Observable<V>) => Subscription {\n    return ((observableOrValue?: V | Observable<V>): Subscription => {\n      let initializationError: Error | undefined;\n      // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      const subscription = observable$\n        .pipe(\n          concatMap(\n            value =>\n              this.isInitialized\n                ? of(value).pipe(withLatestFrom(this.stateSubject$))\n                : // If state was not initialized, we'll throw an error.\n                  throwError(\n                    Error(`${this.constructor.name} has not been initialized`)\n                  )\n          ),\n          takeUntil(this.destroy$)\n        )\n        .subscribe({\n          next: ([value, currentState]) => {\n            this.stateSubject$.next(updaterFn(currentState, value!));\n          },\n          error: error => {\n            initializationError = error;\n            this.stateSubject$.error(error);\n          },\n        });\n\n      if (initializationError) {\n        throw initializationError;\n      }\n      return subscription;\n    }) as unknown extends V\n      ? () => void\n      : (t: V | Observable<V>) => Subscription;\n  }\n\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n  private initState(state: T): void {\n    this.isInitialized = true;\n    this.stateSubject$.next(state);\n  }\n\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn as (state: T) => T)();\n    }\n  }\n\n  /**\n   * Creates a selector.\n   *\n   * This supports chaining up to 4 selectors. More could be added as needed.\n   *\n   * @param projector A pure projection function that takes the current state and\n   *   returns some new slice/projection of that state.\n   * @return An observable of the projector results.\n   */\n  select<R>(projector: (s: T) => R): Observable<R>;\n  select<R, S1>(s1: Observable<S1>, projector: (s1: S1) => R): Observable<R>;\n  select<R, S1, S2>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    projector: (s1: S1, s2: S2) => R\n  ): Observable<R>;\n  select<R, S1, S2, S3>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    s3: Observable<S3>,\n    projector: (s1: S1, s2: S2, s3: S3) => R\n  ): Observable<R>;\n  select<R, S1, S2, S3, S4>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    s3: Observable<S3>,\n    s4: Observable<S4>,\n    projector: (s1: S1, s2: S2, s3: S3, s4: S4) => R\n  ): Observable<R>;\n  select<R>(...args: any[]): Observable<R> {\n    let observable$: Observable<R>;\n    // project is always the last argument, so `pop` it from args.\n    const projector: (...args: any[]) => R = args.pop();\n    if (args.length === 0) {\n      // If projector was the only argument then we'll use map operator.\n      observable$ = this.stateSubject$.pipe(map(projector));\n    } else {\n      // If there are multiple arguments, we're chaining selectors, so we need\n      // to take the combineLatest of them before calling the map function.\n      observable$ = combineLatest(args).pipe(\n        // The most performant way to combine Observables avoiding unnecessary\n        // emissions and projector calls.\n        debounceSync(),\n        map((args: any[]) => projector(...args))\n      );\n    }\n    const distinctSharedObservable$ = observable$.pipe(\n      distinctUntilChanged(),\n      shareReplay({\n        refCount: true,\n        bufferSize: 1,\n      }),\n      takeUntil(this.destroy$)\n    );\n    return distinctSharedObservable$;\n  }\n\n  /**\n   * Creates an effect.\n   *\n   * This effect is subscribed to for the life of the @Component.\n   * @param generator A function that takes an origin Observable input and\n   *     returns an Observable. The Observable that is returned will be\n   *     subscribed to for the life of the component.\n   * @return A function that, when called, will trigger the origin Observable.\n   */\n  effect<V, R = unknown>(\n    generator: (origin$: Observable<V>) => Observable<R>\n  ): EffectReturnFn<V> {\n    const origin$ = new Subject<V>();\n    generator(origin$)\n      // tied to the lifecycle 👇 of ComponentStore\n      .pipe(takeUntil(this.destroy$))\n      .subscribe();\n\n    return (observableOrValue?: V | Observable<V>): Subscription => {\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      return observable$.pipe(takeUntil(this.destroy$)).subscribe(value => {\n        // any new 👇 value is pushed into a stream\n        origin$.next(value);\n      });\n    };\n  }\n}\n"]}