{"version":3,"sources":["ng://@ngrx/component-store/src/debounceSync.ts","ng://@ngrx/component-store/src/component-store.ts"],"names":["debounceSync","source","Observable","observer","actionSubscription","actionValue","rootSubscription","Subscription","add","subscribe","complete","next","error","value","asapScheduler","schedule","undefined","ComponentStore","defaultState","this","destroySubject$","ReplaySubject","destroy$","asObservable","stateSubject$","isInitialized","state$","select","s","initState","prototype","ngOnDestroy","updater","updaterFn","_this","observableOrValue","initializationError","subscription","isObservable","of","pipe","concatMap","withLatestFrom","throwError","Error","constructor","name","takeUntil","_a","_b","__read","currentState","state","setState","stateOrUpdaterFn","args","_i","arguments","length","projector","pop","distinctSharedObservable$","map","combineLatest","apply","__spread","distinctUntilChanged","shareReplay","refCount","bufferSize","effect","generator","origin$","Subject"],"mappings":"wWA+BgBA,IACd,OAAA,SAAOC,GACL,OAAA,IAAIC,EAAAA,YAAU,SAAIC,OACZC,EACAC,EACEC,EAAmB,IAAIC,EAAAA,aAsB7B,OArBAD,EAAiBE,IACfP,EAAOQ,UAAU,CACfC,SAAQ,WACFN,GACFD,EAASQ,KAAKN,GAEhBF,EAASO,YAEXE,MAAK,SAAEA,GAAS,OAAAT,EAASS,MAAMA,IAC/BD,KAAI,SAAEE,GACJR,EAAcQ,EACTT,IACHA,EAAqBU,EAAAA,cAAcC,UAAQ,WACzCZ,EAASQ,KAAKN,GACdD,OAAqBY,KAEvBV,EAAiBE,IAAIJ,QAKtBE,wbClBX,SAAAW,EAAYC,GATKC,KAAAC,gBAAkB,IAAIC,EAAAA,cAAoB,GAElDF,KAAAG,SAAWH,KAAKC,gBAAgBG,eAExBJ,KAAAK,cAAgB,IAAIH,EAAAA,cAAiB,GAC9CF,KAAAM,eAAgB,EAEfN,KAAAO,OAAwBP,KAAKQ,QAAM,SAAEC,GAAM,OAAAA,KAK9CV,GACFC,KAAKU,UAAUX,GA+KrB,OA1KED,EAAAa,UAAAC,YAAA,WACEZ,KAAKK,cAAcd,WACnBS,KAAKC,gBAAgBT,QAkBvBM,EAAAa,UAAAE,QAAA,SACEC,GADF,IAAAC,EAAAf,KAGE,OAAA,SAASgB,OACHC,EAOEC,GAHcC,EAAAA,aAAaH,GAC7BA,EACAI,EAAAA,GAAGJ,IAEJK,KACCC,EAAAA,WAAS,SAAE5B,GACT,OAAAqB,EAAKT,cACDc,EAAAA,GAAG1B,GAAO2B,KAAKE,EAAAA,eAAeR,EAAKV,gBAEnCmB,EAAAA,WACEC,MAASV,EAAKW,YAAYC,KAAI,iCAGtCC,EAAAA,UAAUb,EAAKZ,WAEhBb,UAAU,CACTE,KAAI,SAAGqC,OAAAC,EAAAC,EAAAF,EAAA,GAACnC,EAAAoC,EAAA,GAAOE,EAAAF,EAAA,GACbf,EAAKV,cAAcb,KAAKsB,EAAUkB,EAAY,KAEhDvC,MAAK,SAAGA,GACNwB,EAAsBxB,EACtBsB,EAAKV,cAAcZ,MAAMA,MAI/B,GAAIwB,EAEF,MAAA,EAEF,OAAOC,KAUHpB,EAAAa,UAAAD,UAAR,SAAkBuB,GAChBjC,KAAKM,eAAgB,EACrBN,KAAKK,cAAcb,KAAKyC,IAQ1BnC,EAAAa,UAAAuB,SAAA,SAASC,GACyB,mBAArBA,EACTnC,KAAKU,UAAUyB,GAEfnC,KAAKa,QAAO,EAAZb,IAiCJF,EAAAa,UAAAH,OAAA,eAAU,IAAA4B,EAAA,GAAAC,EAAA,EAAAA,EAAAC,UAAAC,OAAAF,IAAAD,EAAAC,GAAAC,UAAAD,OAGFG,EAAmCJ,EAAKK,MAcxCC,GAbc,IAAhBN,EAAKG,OAEOvC,KAAKK,cAAcgB,KAAKsB,EAAAA,IAAIH,IAI5BI,EAAAA,cAAcR,GAAMf,KAGhCxC,IACA8D,EAAAA,KAAG,SAAEP,GAAgB,OAAAI,EAASK,WAAA,EAAAC,EAAIV,SAGQf,KAC5C0B,EAAAA,uBACAC,EAAAA,YAAY,CACVC,UAAU,EACVC,WAAY,IAEdtB,EAAAA,UAAU5B,KAAKG,WAEjB,OAAOuC,GAYT5C,EAAAa,UAAAwC,OAAA,SACEC,GADF,IAAArC,EAAAf,KAGQqD,EAAU,IAAIC,EAAAA,QAMpB,OALAF,EAAUC,GAEPhC,KAAKO,EAAAA,UAAU5B,KAAKG,WACpBb,YAEH,SAAQ0B,GAIN,OAHoBG,EAAAA,aAAaH,GAC7BA,EACAI,EAAAA,GAAGJ,IACYK,KAAKO,EAAAA,UAAUb,EAAKZ,WAAWb,WAAS,SAAEI,GAE3D2D,EAAQ7D,KAAKE,QAIrBI","sourcesContent":["/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport {\n  asapScheduler,\n  MonoTypeOperatorFunction,\n  Observable,\n  Subscription,\n} from 'rxjs';\n\nexport function debounceSync<T>(): MonoTypeOperatorFunction<T> {\n  return source =>\n    new Observable<T>(observer => {\n      let actionSubscription: Subscription | undefined;\n      let actionValue: T | undefined;\n      const rootSubscription = new Subscription();\n      rootSubscription.add(\n        source.subscribe({\n          complete: () => {\n            if (actionSubscription) {\n              observer.next(actionValue);\n            }\n            observer.complete();\n          },\n          error: error => observer.error(error),\n          next: value => {\n            actionValue = value;\n            if (!actionSubscription) {\n              actionSubscription = asapScheduler.schedule(() => {\n                observer.next(actionValue);\n                actionSubscription = undefined;\n              });\n              rootSubscription.add(actionSubscription);\n            }\n          },\n        })\n      );\n      return rootSubscription;\n    });\n}\n","import {\n  isObservable,\n  Observable,\n  of,\n  ReplaySubject,\n  Subscription,\n  throwError,\n  combineLatest,\n  Subject,\n} from 'rxjs';\nimport {\n  concatMap,\n  takeUntil,\n  withLatestFrom,\n  map,\n  distinctUntilChanged,\n  shareReplay,\n} from 'rxjs/operators';\nimport { debounceSync } from './debounceSync';\n\n/**\n * Return type of the effect, that behaves differently based on whether the\n * argument is passed to the callback.\n */\nexport interface EffectReturnFn<T> {\n  (): void;\n  (t: T | Observable<T>): Subscription;\n}\n\nexport class ComponentStore<T extends object> {\n  // Should be used only in ngOnDestroy.\n  private readonly destroySubject$ = new ReplaySubject<void>(1);\n  // Exposed to any extending Store to be used for the teardowns.\n  readonly destroy$ = this.destroySubject$.asObservable();\n\n  private readonly stateSubject$ = new ReplaySubject<T>(1);\n  private isInitialized = false;\n  // Needs to be after destroy$ is declared because it's used in select.\n  readonly state$: Observable<T> = this.select((s) => s);\n\n  constructor(defaultState?: T) {\n    // State can be initialized either through constructor, or initState or\n    // setState.\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n  }\n\n  /** Completes all relevant Observable streams. */\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Everytime this function is called\n   *     subscribers will be notified of the state change.\n   */\n  updater<V>(\n    updaterFn: (state: T, value: V) => T\n  ): unknown extends V ? () => void : (t: V | Observable<V>) => Subscription {\n    return ((observableOrValue?: V | Observable<V>): Subscription => {\n      let initializationError: Error | undefined;\n      // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      const subscription = observable$\n        .pipe(\n          concatMap((value) =>\n            this.isInitialized\n              ? of(value).pipe(withLatestFrom(this.stateSubject$))\n              : // If state was not initialized, we'll throw an error.\n                throwError(\n                  Error(`${this.constructor.name} has not been initialized`)\n                )\n          ),\n          takeUntil(this.destroy$)\n        )\n        .subscribe({\n          next: ([value, currentState]) => {\n            this.stateSubject$.next(updaterFn(currentState, value!));\n          },\n          error: (error: Error) => {\n            initializationError = error;\n            this.stateSubject$.error(error);\n          },\n        });\n\n      if (initializationError) {\n        // prettier-ignore\n        throw /** @type {!Error} */ (initializationError);\n      }\n      return subscription;\n    }) as unknown extends V\n      ? () => void\n      : (t: V | Observable<V>) => Subscription;\n  }\n\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n  private initState(state: T): void {\n    this.isInitialized = true;\n    this.stateSubject$.next(state);\n  }\n\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn as (state: T) => T)();\n    }\n  }\n\n  /**\n   * Creates a selector.\n   *\n   * This supports chaining up to 4 selectors. More could be added as needed.\n   *\n   * @param projector A pure projection function that takes the current state and\n   *   returns some new slice/projection of that state.\n   * @return An observable of the projector results.\n   */\n  select<R>(projector: (s: T) => R): Observable<R>;\n  select<R, S1>(s1: Observable<S1>, projector: (s1: S1) => R): Observable<R>;\n  select<R, S1, S2>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    projector: (s1: S1, s2: S2) => R\n  ): Observable<R>;\n  select<R, S1, S2, S3>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    s3: Observable<S3>,\n    projector: (s1: S1, s2: S2, s3: S3) => R\n  ): Observable<R>;\n  select<R, S1, S2, S3, S4>(\n    s1: Observable<S1>,\n    s2: Observable<S2>,\n    s3: Observable<S3>,\n    s4: Observable<S4>,\n    projector: (s1: S1, s2: S2, s3: S3, s4: S4) => R\n  ): Observable<R>;\n  select<R>(...args: any[]): Observable<R> {\n    let observable$: Observable<R>;\n    // project is always the last argument, so `pop` it from args.\n    const projector: (...args: any[]) => R = args.pop();\n    if (args.length === 0) {\n      // If projector was the only argument then we'll use map operator.\n      observable$ = this.stateSubject$.pipe(map(projector));\n    } else {\n      // If there are multiple arguments, we're chaining selectors, so we need\n      // to take the combineLatest of them before calling the map function.\n      observable$ = combineLatest(args).pipe(\n        // The most performant way to combine Observables avoiding unnecessary\n        // emissions and projector calls.\n        debounceSync(),\n        map((args: any[]) => projector(...args))\n      );\n    }\n    const distinctSharedObservable$ = observable$.pipe(\n      distinctUntilChanged(),\n      shareReplay({\n        refCount: true,\n        bufferSize: 1,\n      }),\n      takeUntil(this.destroy$)\n    );\n    return distinctSharedObservable$;\n  }\n\n  /**\n   * Creates an effect.\n   *\n   * This effect is subscribed to for the life of the @Component.\n   * @param generator A function that takes an origin Observable input and\n   *     returns an Observable. The Observable that is returned will be\n   *     subscribed to for the life of the component.\n   * @return A function that, when called, will trigger the origin Observable.\n   */\n  effect<V, R = unknown>(\n    generator: (origin$: Observable<V>) => Observable<R>\n  ): EffectReturnFn<V> {\n    const origin$ = new Subject<V>();\n    generator(origin$)\n      // tied to the lifecycle 👇 of ComponentStore\n      .pipe(takeUntil(this.destroy$))\n      .subscribe();\n\n    return (observableOrValue?: V | Observable<V>): Subscription => {\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      return observable$.pipe(takeUntil(this.destroy$)).subscribe((value) => {\n        // any new 👇 value is pushed into a stream\n        origin$.next(value);\n      });\n    };\n  }\n}\n"]}