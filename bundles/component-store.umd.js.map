{"version":3,"file":"component-store.umd.js","sources":["../../../../../modules/component-store/src/component-store.ts","../../../../../modules/component-store/index.ts"],"sourcesContent":["import {\n  isObservable,\n  Observable,\n  of,\n  ReplaySubject,\n  Subscription,\n  throwError,\n} from 'rxjs';\nimport { concatMap, takeUntil, withLatestFrom } from 'rxjs/operators';\n\nexport class ComponentStore<T extends object> {\n  private readonly stateSubject$ = new ReplaySubject<T>(1);\n  private isInitialized = false;\n  readonly state$: Observable<T> = this.stateSubject$.asObservable();\n\n  // Should be used only in ngOnDestroy.\n  private readonly destroySubject$ = new ReplaySubject<void>(1);\n  // Exposed to any extending Store to be used for the teardowns.\n  readonly destroy$ = this.destroySubject$.asObservable();\n\n  constructor(defaultState?: T) {\n    // State can be initialized either through constructor, or initState or\n    // setState.\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n  }\n\n  /** Completes all relevant Observable streams. */\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Everytime this function is called\n   *     subscribers will be notified of the state change.\n   */\n  updater<V>(\n    updaterFn: (state: T, value: V) => T\n  ): unknown extends V ? () => void : (t: V | Observable<V>) => Subscription {\n    return ((observableOrValue?: V | Observable<V>): Subscription => {\n      let initializationError: Error | undefined;\n      // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      const subscription = observable$\n        .pipe(\n          concatMap(\n            value =>\n              this.isInitialized\n                ? of(value).pipe(withLatestFrom(this.stateSubject$))\n                : // If state was not initialized, we'll throw an error.\n                  throwError(\n                    Error(`${this.constructor.name} has not been initialized`)\n                  )\n          ),\n          takeUntil(this.destroy$)\n        )\n        .subscribe({\n          next: ([value, currentState]) => {\n            this.stateSubject$.next(updaterFn(currentState, value!));\n          },\n          error: error => {\n            initializationError = error;\n            this.stateSubject$.error(error);\n          },\n        });\n\n      if (initializationError) {\n        throw initializationError;\n      }\n      return subscription;\n    }) as unknown extends V\n      ? () => void\n      : (t: V | Observable<V>) => Subscription;\n  }\n\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n  private initState(state: T): void {\n    this.isInitialized = true;\n    this.stateSubject$.next(state);\n  }\n\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn as (state: T) => T)();\n    }\n  }\n}\n","/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\nexport * from './public_api';\n"],"names":["ReplaySubject","isObservable","of","concatMap","withLatestFrom","throwError","takeUntil"],"mappings":";;;;;;;;;;;;QAoBE,wBAAY,YAAgB;YATX,kBAAa,GAAG,IAAIA,kBAAa,CAAI,CAAC,CAAC,CAAC;YACjD,kBAAa,GAAG,KAAK,CAAC;YACrB,WAAM,GAAkB,IAAI,CAAC,aAAa,CAAC,YAAY,EAAE,CAAC;;YAGlD,oBAAe,GAAG,IAAIA,kBAAa,CAAO,CAAC,CAAC,CAAC;;YAErD,aAAQ,GAAG,IAAI,CAAC,eAAe,CAAC,YAAY,EAAE,CAAC;;;YAKtD,IAAI,YAAY,EAAE;gBAChB,IAAI,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;aAC9B;SACF;;QAGD,oCAAW,GAAX;YACE,IAAI,CAAC,aAAa,CAAC,QAAQ,EAAE,CAAC;YAC9B,IAAI,CAAC,eAAe,CAAC,IAAI,EAAE,CAAC;SAC7B;;;;;;;;;;;;;;;;QAiBD,gCAAO,GAAP,UACE,SAAoC;YADtC,iBAyCC;YAtCC,QAAQ,UAAC,iBAAqC;gBAC5C,IAAI,mBAAsC,CAAC;;;;gBAI3C,IAAM,WAAW,GAAGC,iBAAY,CAAC,iBAAiB,CAAC;sBAC/C,iBAAiB;sBACjBC,OAAE,CAAC,iBAAiB,CAAC,CAAC;gBAC1B,IAAM,YAAY,GAAG,WAAW;qBAC7B,IAAI,CACHC,mBAAS,CACP,UAAA,KAAK;oBACH,OAAA,KAAI,CAAC,aAAa;0BACdD,OAAE,CAAC,KAAK,CAAC,CAAC,IAAI,CAACE,wBAAc,CAAC,KAAI,CAAC,aAAa,CAAC,CAAC;;4BAElDC,eAAU,CACR,KAAK,CAAI,KAAI,CAAC,WAAW,CAAC,IAAI,8BAA2B,CAAC,CAC3D;iBAAA,CACR,EACDC,mBAAS,CAAC,KAAI,CAAC,QAAQ,CAAC,CACzB;qBACA,SAAS,CAAC;oBACT,IAAI,EAAE,UAAC,EAAqB;4BAArB,wBAAqB,EAApB,aAAK,EAAE,oBAAY;wBACzB,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,EAAE,KAAM,CAAC,CAAC,CAAC;qBAC1D;oBACD,KAAK,EAAE,UAAA,KAAK;wBACV,mBAAmB,GAAG,KAAK,CAAC;wBAC5B,KAAI,CAAC,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;qBACjC;iBACF,CAAC,CAAC;gBAEL,IAAI,mBAAmB,EAAE;oBACvB,MAAM,mBAAmB,CAAC;iBAC3B;gBACD,OAAO,YAAY,CAAC;aACrB,EAE0C;SAC5C;;;;;QAMO,kCAAS,GAAjB,UAAkB,KAAQ;YACxB,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC;YAC1B,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;SAChC;;;;;;QAOD,iCAAQ,GAAR,UAAS,gBAAuC;YAC9C,IAAI,OAAO,gBAAgB,KAAK,UAAU,EAAE;gBAC1C,IAAI,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC;aAClC;iBAAM;gBACL,IAAI,CAAC,OAAO,CAAC,gBAAmC,CAAC,EAAE,CAAC;aACrD;SACF;QACH,qBAAC;IAAD,CAAC;;ICjHD;;;;OAIG;;;;;;;;;;;;"}