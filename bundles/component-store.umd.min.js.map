{"version":3,"sources":["modules/component-store/component-store.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ngrx","componentStore","tslib","rxjs","operators","this","ComponentStore","defaultState","stateSubject$","ReplaySubject","isInitialized","state$","asObservable","destroySubject$","destroy$","initState","prototype","ngOnDestroy","complete","next","updater","updaterFn","_this","observableOrValue","initializationError","subscription","isObservable","of","pipe","concatMap","value","withLatestFrom","throwError","Error","constructor","name","takeUntil","subscribe","_a","_b","__read","error","state","setState","stateOrUpdaterFn","Object","defineProperty"],"mappings":";;;;;CAKC,SAAUA,EAAQC,GACI,iBAAZC,SAA0C,oBAAXC,OAAyBF,EAAQC,QAASE,QAAQ,SAAUA,QAAQ,QAASA,QAAQ,mBACzG,mBAAXC,QAAyBA,OAAOC,IAAMD,OAAO,wBAAyB,CAAC,UAAW,QAAS,OAAQ,kBAAmBJ,GACnGA,IAAzBD,EAASA,GAAUO,MAAsBC,KAAOR,EAAOQ,MAAQ,GAAIR,EAAOQ,KAAKC,eAAiB,IAAKT,EAAOU,MAAOV,EAAOW,KAAMX,EAAOW,KAAKC,WAHjJ,CAIEC,MAAM,SAAWX,EAASQ,EAAOC,EAAMC,GAAa,aAElD,IAAIE,EAAgC,WAChC,SAASA,EAAeC,GACpBF,KAAKG,cAAgB,IAAIL,EAAKM,cAAc,GAC5CJ,KAAKK,eAAgB,EACrBL,KAAKM,OAASN,KAAKG,cAAcI,eAEjCP,KAAKQ,gBAAkB,IAAIV,EAAKM,cAAc,GAE9CJ,KAAKS,SAAWT,KAAKQ,gBAAgBD,eAGjCL,GACAF,KAAKU,UAAUR,GA6EvB,OAzEAD,EAAeU,UAAUC,YAAc,WACnCZ,KAAKG,cAAcU,WACnBb,KAAKQ,gBAAgBM,QAiBzBb,EAAeU,UAAUI,QAAU,SAAUC,GACzC,IAAIC,EAAQjB,KACZ,OAAO,SAAWkB,GACd,IAAIC,EAOAC,GAHctB,EAAKuB,aAAaH,GAC9BA,EACApB,EAAKwB,GAAGJ,IAETK,KAAKxB,EAAUyB,WAAU,SAAUC,GACpC,OAAOR,EAAMZ,cACPP,EAAKwB,GAAGG,GAAOF,KAAKxB,EAAU2B,eAAeT,EAAMd,gBAEjDL,EAAK6B,WAAWC,MAAMX,EAAMY,YAAYC,KAAO,iCACvD/B,EAAUgC,UAAUd,EAAMR,WACzBuB,UAAU,CACXlB,KAAM,SAAUmB,GACZ,IAAIC,EAAKrC,EAAMsC,OAAOF,EAAI,GAC1BhB,EAAMd,cAAcW,KAAKE,EADmCkB,EAAG,GAAzBA,EAAG,MAG7CE,MAAO,SAAUA,GACbjB,EAAsBiB,EACtBnB,EAAMd,cAAciC,MAAMA,MAGlC,GAAIjB,EACA,MAAMA,EAEV,OAAOC,IAOfnB,EAAeU,UAAUD,UAAY,SAAU2B,GAC3CrC,KAAKK,eAAgB,EACrBL,KAAKG,cAAcW,KAAKuB,IAO5BpC,EAAeU,UAAU2B,SAAW,SAAUC,GACV,mBAArBA,EACPvC,KAAKU,UAAU6B,GAGfvC,KAAKe,QAAQwB,EAAbvC,IAGDC,EAzFwB,GAkGnCZ,EAAQY,eAAiBA,EAEzBuC,OAAOC,eAAepD,EAAS,aAAc,CAAEoC,OAAO","sourcesContent":["/**\n * @license NgRx 9.1.2+11.sha-6caae70\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@ngrx/component-store', ['exports', 'tslib', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ngrx = global.ngrx || {}, global.ngrx.componentStore = {}), global.tslib, global.rxjs, global.rxjs.operators));\n}(this, (function (exports, tslib, rxjs, operators) { 'use strict';\n\n    var ComponentStore = /** @class */ (function () {\n        function ComponentStore(defaultState) {\n            this.stateSubject$ = new rxjs.ReplaySubject(1);\n            this.isInitialized = false;\n            this.state$ = this.stateSubject$.asObservable();\n            // Should be used only in ngOnDestroy.\n            this.destroySubject$ = new rxjs.ReplaySubject(1);\n            // Exposed to any extending Store to be used for the teardowns.\n            this.destroy$ = this.destroySubject$.asObservable();\n            // State can be initialized either through constructor, or initState or\n            // setState.\n            if (defaultState) {\n                this.initState(defaultState);\n            }\n        }\n        /** Completes all relevant Observable streams. */\n        ComponentStore.prototype.ngOnDestroy = function () {\n            this.stateSubject$.complete();\n            this.destroySubject$.next();\n        };\n        /**\n         * Creates an updater.\n         *\n         * Throws an error if updater is called with synchronous values (either\n         * imperative value or Observable that is synchronous) before ComponentStore\n         * is initialized. If called with async Observable before initialization then\n         * state will not be updated and subscription would be closed.\n         *\n         * @param updaterFn A static updater function that takes 2 parameters (the\n         * current state and an argument object) and returns a new instance of the\n         * state.\n         * @return A function that accepts one argument which is forwarded as the\n         *     second argument to `updaterFn`. Everytime this function is called\n         *     subscribers will be notified of the state change.\n         */\n        ComponentStore.prototype.updater = function (updaterFn) {\n            var _this = this;\n            return (function (observableOrValue) {\n                var initializationError;\n                // We can receive either the value or an observable. In case it's a\n                // simple value, we'll wrap it with `of` operator to turn it into\n                // Observable.\n                var observable$ = rxjs.isObservable(observableOrValue)\n                    ? observableOrValue\n                    : rxjs.of(observableOrValue);\n                var subscription = observable$\n                    .pipe(operators.concatMap(function (value) {\n                    return _this.isInitialized\n                        ? rxjs.of(value).pipe(operators.withLatestFrom(_this.stateSubject$))\n                        : // If state was not initialized, we'll throw an error.\n                            rxjs.throwError(Error(_this.constructor.name + \" has not been initialized\"));\n                }), operators.takeUntil(_this.destroy$))\n                    .subscribe({\n                    next: function (_a) {\n                        var _b = tslib.__read(_a, 2), value = _b[0], currentState = _b[1];\n                        _this.stateSubject$.next(updaterFn(currentState, value));\n                    },\n                    error: function (error) {\n                        initializationError = error;\n                        _this.stateSubject$.error(error);\n                    },\n                });\n                if (initializationError) {\n                    throw initializationError;\n                }\n                return subscription;\n            });\n        };\n        /**\n         * Initializes state. If it was already initialized then it resets the\n         * state.\n         */\n        ComponentStore.prototype.initState = function (state) {\n            this.isInitialized = true;\n            this.stateSubject$.next(state);\n        };\n        /**\n         * Sets the state specific value.\n         * @param stateOrUpdaterFn object of the same type as the state or an\n         * updaterFn, returning such object.\n         */\n        ComponentStore.prototype.setState = function (stateOrUpdaterFn) {\n            if (typeof stateOrUpdaterFn !== 'function') {\n                this.initState(stateOrUpdaterFn);\n            }\n            else {\n                this.updater(stateOrUpdaterFn)();\n            }\n        };\n        return ComponentStore;\n    }());\n\n    /**\n     * DO NOT EDIT\n     *\n     * This file is automatically generated at build\n     */\n\n    exports.ComponentStore = ComponentStore;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=component-store.umd.js.map\n"]}