{"version":3,"sources":["modules/component-store/component-store.umd.js"],"names":["global","factory","exports","module","require","define","amd","self","ngrx","componentStore","tslib","rxjs","operators","this","debounceSync","source","Observable","observer","actionSubscription","actionValue","rootSubscription","Subscription","add","subscribe","complete","next","error","value","asapScheduler","schedule","undefined","ComponentStore","defaultState","destroySubject$","ReplaySubject","destroy$","asObservable","stateSubject$","isInitialized","state$","select","s","initState","prototype","ngOnDestroy","updater","updaterFn","_this","observableOrValue","initializationError","subscription","isObservable","of","pipe","concatMap","withLatestFrom","throwError","Error","constructor","name","takeUntil","_a","_b","__read","state","setState","stateOrUpdaterFn","args","_i","arguments","length","projector","pop","distinctSharedObservable$","map","combineLatest","apply","__spread","distinctUntilChanged","shareReplay","refCount","bufferSize","Object","defineProperty"],"mappings":"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","sourcesContent":["/**\n * @license NgRx 9.2.0+2.sha-aba7368\n * (c) 2015-2018 Brandon Roberts, Mike Ryan, Rob Wormald, Victor Savkin\n * License: MIT\n */\n(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('tslib'), require('rxjs'), require('rxjs/operators')) :\n    typeof define === 'function' && define.amd ? define('@ngrx/component-store', ['exports', 'tslib', 'rxjs', 'rxjs/operators'], factory) :\n    (global = global || self, factory((global.ngrx = global.ngrx || {}, global.ngrx.componentStore = {}), global.tslib, global.rxjs, global.rxjs.operators));\n}(this, (function (exports, tslib, rxjs, operators) { 'use strict';\n\n    /**\n     * @license MIT License\n     *\n     * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n     *\n     * Permission is hereby granted, free of charge, to any person obtaining a copy\n     * of this software and associated documentation files (the \"Software\"), to deal\n     * in the Software without restriction, including without limitation the rights\n     * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n     * copies of the Software, and to permit persons to whom the Software is\n     * furnished to do so, subject to the following conditions:\n     *\n     * The above copyright notice and this permission notice shall be included in all\n     * copies or substantial portions of the Software.\n     *\n     * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n     * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n     * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n     * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n     * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n     * SOFTWARE.\n     */\n    function debounceSync() {\n        return function (source) {\n            return new rxjs.Observable(function (observer) {\n                var actionSubscription;\n                var actionValue;\n                var rootSubscription = new rxjs.Subscription();\n                rootSubscription.add(source.subscribe({\n                    complete: function () {\n                        if (actionSubscription) {\n                            observer.next(actionValue);\n                        }\n                        observer.complete();\n                    },\n                    error: function (error) { return observer.error(error); },\n                    next: function (value) {\n                        actionValue = value;\n                        if (!actionSubscription) {\n                            actionSubscription = rxjs.asapScheduler.schedule(function () {\n                                observer.next(actionValue);\n                                actionSubscription = undefined;\n                            });\n                            rootSubscription.add(actionSubscription);\n                        }\n                    },\n                }));\n                return rootSubscription;\n            });\n        };\n    }\n\n    var ComponentStore = /** @class */ (function () {\n        function ComponentStore(defaultState) {\n            // Should be used only in ngOnDestroy.\n            this.destroySubject$ = new rxjs.ReplaySubject(1);\n            // Exposed to any extending Store to be used for the teardowns.\n            this.destroy$ = this.destroySubject$.asObservable();\n            this.stateSubject$ = new rxjs.ReplaySubject(1);\n            this.isInitialized = false;\n            // Needs to be after destroy$ is declared because it's used in select.\n            this.state$ = this.select(function (s) { return s; });\n            // State can be initialized either through constructor, or initState or\n            // setState.\n            if (defaultState) {\n                this.initState(defaultState);\n            }\n        }\n        /** Completes all relevant Observable streams. */\n        ComponentStore.prototype.ngOnDestroy = function () {\n            this.stateSubject$.complete();\n            this.destroySubject$.next();\n        };\n        /**\n         * Creates an updater.\n         *\n         * Throws an error if updater is called with synchronous values (either\n         * imperative value or Observable that is synchronous) before ComponentStore\n         * is initialized. If called with async Observable before initialization then\n         * state will not be updated and subscription would be closed.\n         *\n         * @param updaterFn A static updater function that takes 2 parameters (the\n         * current state and an argument object) and returns a new instance of the\n         * state.\n         * @return A function that accepts one argument which is forwarded as the\n         *     second argument to `updaterFn`. Everytime this function is called\n         *     subscribers will be notified of the state change.\n         */\n        ComponentStore.prototype.updater = function (updaterFn) {\n            var _this = this;\n            return (function (observableOrValue) {\n                var initializationError;\n                // We can receive either the value or an observable. In case it's a\n                // simple value, we'll wrap it with `of` operator to turn it into\n                // Observable.\n                var observable$ = rxjs.isObservable(observableOrValue)\n                    ? observableOrValue\n                    : rxjs.of(observableOrValue);\n                var subscription = observable$\n                    .pipe(operators.concatMap(function (value) {\n                    return _this.isInitialized\n                        ? rxjs.of(value).pipe(operators.withLatestFrom(_this.stateSubject$))\n                        : // If state was not initialized, we'll throw an error.\n                            rxjs.throwError(Error(_this.constructor.name + \" has not been initialized\"));\n                }), operators.takeUntil(_this.destroy$))\n                    .subscribe({\n                    next: function (_a) {\n                        var _b = tslib.__read(_a, 2), value = _b[0], currentState = _b[1];\n                        _this.stateSubject$.next(updaterFn(currentState, value));\n                    },\n                    error: function (error) {\n                        initializationError = error;\n                        _this.stateSubject$.error(error);\n                    },\n                });\n                if (initializationError) {\n                    throw initializationError;\n                }\n                return subscription;\n            });\n        };\n        /**\n         * Initializes state. If it was already initialized then it resets the\n         * state.\n         */\n        ComponentStore.prototype.initState = function (state) {\n            this.isInitialized = true;\n            this.stateSubject$.next(state);\n        };\n        /**\n         * Sets the state specific value.\n         * @param stateOrUpdaterFn object of the same type as the state or an\n         * updaterFn, returning such object.\n         */\n        ComponentStore.prototype.setState = function (stateOrUpdaterFn) {\n            if (typeof stateOrUpdaterFn !== 'function') {\n                this.initState(stateOrUpdaterFn);\n            }\n            else {\n                this.updater(stateOrUpdaterFn)();\n            }\n        };\n        ComponentStore.prototype.select = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var observable$;\n            // project is always the last argument, so `pop` it from args.\n            var projector = args.pop();\n            if (args.length === 0) {\n                // If projector was the only argument then we'll use map operator.\n                observable$ = this.stateSubject$.pipe(operators.map(projector));\n            }\n            else {\n                // If there are multiple arguments, we're chaining selectors, so we need\n                // to take the combineLatest of them before calling the map function.\n                observable$ = rxjs.combineLatest(args).pipe(\n                // The most performant way to combine Observables avoiding unnecessary\n                // emissions and projector calls.\n                debounceSync(), operators.map(function (args) { return projector.apply(void 0, tslib.__spread(args)); }));\n            }\n            var distinctSharedObservable$ = observable$.pipe(operators.distinctUntilChanged(), operators.shareReplay({\n                refCount: true,\n                bufferSize: 1,\n            }), operators.takeUntil(this.destroy$));\n            return distinctSharedObservable$;\n        };\n        return ComponentStore;\n    }());\n\n    /**\n     * DO NOT EDIT\n     *\n     * This file is automatically generated at build\n     */\n\n    exports.ComponentStore = ComponentStore;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=component-store.umd.js.map\n"]}