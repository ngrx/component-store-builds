{"version":3,"file":"ngrx-component-store.mjs","sources":["../../../../modules/component-store/src/debounce-sync.ts","../../../../modules/component-store/src/lifecycle_hooks.ts","../../../../modules/component-store/src/component-store.ts","../../../../modules/component-store/src/tap-response.ts","../../../../modules/component-store/index.ts","../../../../modules/component-store/ngrx-component-store.ts"],"sourcesContent":["/**\n * @license MIT License\n *\n * Copyright (c) 2017-2020 Nicholas Jamieson and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport {\n  asapScheduler,\n  MonoTypeOperatorFunction,\n  Observable,\n  Subscription,\n} from 'rxjs';\n\nexport function debounceSync<T>(): MonoTypeOperatorFunction<T> {\n  return (source) =>\n    new Observable<T>((observer) => {\n      let actionSubscription: Subscription | undefined;\n      let actionValue: T | undefined;\n      const rootSubscription = new Subscription();\n      rootSubscription.add(\n        source.subscribe({\n          complete: () => {\n            if (actionSubscription) {\n              observer.next(actionValue);\n            }\n            observer.complete();\n          },\n          error: (error) => {\n            observer.error(error);\n          },\n          next: (value) => {\n            actionValue = value;\n            if (!actionSubscription) {\n              actionSubscription = asapScheduler.schedule(() => {\n                observer.next(actionValue);\n                actionSubscription = undefined;\n              });\n              rootSubscription.add(actionSubscription);\n            }\n          },\n        })\n      );\n      return rootSubscription;\n    });\n}\n","import { Provider, InjectionToken, Type, inject } from '@angular/core';\nimport { take } from 'rxjs/operators';\nimport { ComponentStore } from './component-store';\n\n/**\n * The interface for the lifecycle hook\n * called after the ComponentStore is instantiated.\n */\nexport interface OnStoreInit {\n  readonly ngrxOnStoreInit: () => void;\n}\n\n/**\n * The interface for the lifecycle hook\n * called only once after the ComponentStore\n * state is first initialized.\n */\nexport interface OnStateInit {\n  readonly ngrxOnStateInit: () => void;\n}\n\n/**\n * Checks to see if the OnInitStore lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\nexport function isOnStoreInitDefined(cs: unknown): cs is OnStoreInit {\n  return typeof (cs as OnStoreInit).ngrxOnStoreInit === 'function';\n}\n\n/**\n * Checks to see if the OnInitState lifecycle hook\n * is defined on the ComponentStore.\n *\n * @param cs ComponentStore type\n * @returns boolean\n */\nexport function isOnStateInitDefined(cs: unknown): cs is OnStateInit {\n  return typeof (cs as OnStateInit).ngrxOnStateInit === 'function';\n}\n\n/**\n * @description\n *\n * Function that returns the ComponentStore\n * class registered as a provider,\n * and uses a factory provider to instantiate the\n * ComponentStore and run the lifecycle hooks\n * defined on the ComponentStore.\n *\n * @param componentStoreClass The ComponentStore with lifecycle hooks\n * @returns Provider[]\n *\n * @usageNotes\n *\n * ```ts\n * @Injectable()\n * export class MyStore\n *    extends ComponentStore<{ init: boolean }>\n *    implements OnStoreInit, OnStateInit\n *   {\n *\n *   constructor() {\n *     super({ init: true });\n *   }\n *\n *   ngrxOnStoreInit() {\n *     // runs once after store has been instantiated\n *   }\n *\n *   ngrxOnStateInit() {\n *     // runs once after store state has been initialized\n *   }\n * }\n *\n * @Component({\n *   providers: [\n *     provideComponentStore(MyStore)\n *   ]\n * })\n * export class MyComponent {\n *   constructor(private myStore: MyStore) {}\n * }\n * ```\n */\nexport function provideComponentStore<T extends object>(\n  componentStoreClass: Type<ComponentStore<T>>\n): Provider[] {\n  const CS_WITH_HOOKS = new InjectionToken<ComponentStore<T>>(\n    '@ngrx/component-store ComponentStore with Hooks'\n  );\n\n  return [\n    { provide: CS_WITH_HOOKS, useClass: componentStoreClass },\n    {\n      provide: componentStoreClass,\n      useFactory: () => {\n        const componentStore = inject(CS_WITH_HOOKS);\n\n        // Set private property that CS has been provided with lifecycle hooks\n        componentStore['ɵhasProvider'] = true;\n\n        if (isOnStoreInitDefined(componentStore)) {\n          componentStore.ngrxOnStoreInit();\n        }\n\n        if (isOnStateInitDefined(componentStore)) {\n          componentStore.state$\n            .pipe(take(1))\n            .subscribe(() => componentStore.ngrxOnStateInit());\n        }\n\n        return componentStore;\n      },\n    },\n  ];\n}\n","import {\n  isObservable,\n  Observable,\n  of,\n  ReplaySubject,\n  Subscription,\n  throwError,\n  combineLatest,\n  Subject,\n  queueScheduler,\n  scheduled,\n  asapScheduler,\n  EMPTY,\n  ObservedValueOf,\n} from 'rxjs';\nimport {\n  takeUntil,\n  withLatestFrom,\n  map,\n  distinctUntilChanged,\n  shareReplay,\n  take,\n  tap,\n  catchError,\n  observeOn,\n} from 'rxjs/operators';\nimport { debounceSync } from './debounce-sync';\nimport {\n  Injectable,\n  OnDestroy,\n  Optional,\n  InjectionToken,\n  Inject,\n  isDevMode,\n  Signal,\n  computed,\n  type ValueEqualityFn,\n  type CreateComputedOptions,\n} from '@angular/core';\nimport { isOnStateInitDefined, isOnStoreInitDefined } from './lifecycle_hooks';\nimport { toSignal } from '@angular/core/rxjs-interop';\n\nexport interface SelectConfig {\n  debounce?: boolean;\n}\n\nexport const INITIAL_STATE_TOKEN = new InjectionToken(\n  '@ngrx/component-store Initial State'\n);\n\nexport type SelectorResults<Selectors extends Observable<unknown>[]> = {\n  [Key in keyof Selectors]: Selectors[Key] extends Observable<infer U>\n    ? U\n    : never;\n};\n\nexport type Projector<Selectors extends Observable<unknown>[], Result> = (\n  ...args: SelectorResults<Selectors>\n) => Result;\n\ntype SignalsProjector<Signals extends Signal<unknown>[], Result> = (\n  ...values: {\n    [Key in keyof Signals]: Signals[Key] extends Signal<infer Value>\n      ? Value\n      : never;\n  }\n) => Result;\n\ninterface SelectSignalOptions<T> {\n  /**\n   * A comparison function which defines equality for select results.\n   */\n  equal?: ValueEqualityFn<T>;\n}\n\n@Injectable()\nexport class ComponentStore<T extends object> implements OnDestroy {\n  // Should be used only in ngOnDestroy.\n  private readonly destroySubject$ = new ReplaySubject<void>(1);\n  // Exposed to any extending Store to be used for the teardown.\n  readonly destroy$ = this.destroySubject$.asObservable();\n\n  private readonly stateSubject$ = new ReplaySubject<T>(1);\n  private isInitialized = false;\n  // Needs to be after destroy$ is declared because it's used in select.\n  readonly state$: Observable<T> = this.select((s) => s);\n  readonly state: Signal<T> = toSignal(\n    this.stateSubject$.pipe(takeUntil(this.destroy$)),\n    { requireSync: false, manualCleanup: true }\n  ) as Signal<T>;\n  private ɵhasProvider = false;\n\n  constructor(@Optional() @Inject(INITIAL_STATE_TOKEN) defaultState?: T) {\n    // State can be initialized either through constructor or setState.\n    if (defaultState) {\n      this.initState(defaultState);\n    }\n\n    this.checkProviderForHooks();\n  }\n\n  /** Completes all relevant Observable streams. */\n  ngOnDestroy() {\n    this.stateSubject$.complete();\n    this.destroySubject$.next();\n  }\n\n  /**\n   * Creates an updater.\n   *\n   * Throws an error if updater is called with synchronous values (either\n   * imperative value or Observable that is synchronous) before ComponentStore\n   * is initialized. If called with async Observable before initialization then\n   * state will not be updated and subscription would be closed.\n   *\n   * @param updaterFn A static updater function that takes 2 parameters (the\n   * current state and an argument object) and returns a new instance of the\n   * state.\n   * @return A function that accepts one argument which is forwarded as the\n   *     second argument to `updaterFn`. Every time this function is called\n   *     subscribers will be notified of the state change.\n   */\n  updater<\n    // Allow to force-provide the type\n    ProvidedType = void,\n    // This type is derived from the `value` property, defaulting to void if it's missing\n    OriginType = ProvidedType,\n    // The Value type is assigned from the Origin\n    ValueType = OriginType,\n    // Return either an empty callback or a function requiring specific types as inputs\n    ReturnType = OriginType extends void\n      ? () => void\n      : (observableOrValue: ValueType | Observable<ValueType>) => Subscription\n  >(updaterFn: (state: T, value: OriginType) => T): ReturnType {\n    return ((\n      observableOrValue?: OriginType | Observable<OriginType>\n    ): Subscription => {\n      // We need to explicitly throw an error if a synchronous error occurs.\n      // This is necessary to make synchronous errors catchable.\n      let isSyncUpdate = true;\n      let syncError: unknown;\n      // We can receive either the value or an observable. In case it's a\n      // simple value, we'll wrap it with `of` operator to turn it into\n      // Observable.\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      const subscription = observable$\n        .pipe(\n          // Push the value into queueScheduler\n          observeOn(queueScheduler),\n          // If the state is not initialized yet, we'll throw an error.\n          tap(() => this.assertStateIsInitialized()),\n          withLatestFrom(this.stateSubject$),\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          map(([value, currentState]) => updaterFn(currentState, value!)),\n          tap((newState) => this.stateSubject$.next(newState)),\n          catchError((error: unknown) => {\n            if (isSyncUpdate) {\n              syncError = error;\n              return EMPTY;\n            }\n\n            return throwError(error);\n          }),\n          takeUntil(this.destroy$)\n        )\n        .subscribe();\n\n      if (syncError) {\n        throw syncError;\n      }\n      isSyncUpdate = false;\n\n      return subscription;\n    }) as unknown as ReturnType;\n  }\n\n  /**\n   * Initializes state. If it was already initialized then it resets the\n   * state.\n   */\n  private initState(state: T): void {\n    scheduled([state], queueScheduler).subscribe((s) => {\n      this.isInitialized = true;\n      this.stateSubject$.next(s);\n    });\n  }\n\n  /**\n   * Sets the state specific value.\n   * @param stateOrUpdaterFn object of the same type as the state or an\n   * updaterFn, returning such object.\n   */\n  setState(stateOrUpdaterFn: T | ((state: T) => T)): void {\n    if (typeof stateOrUpdaterFn !== 'function') {\n      this.initState(stateOrUpdaterFn);\n    } else {\n      this.updater(stateOrUpdaterFn as (state: T) => T)();\n    }\n  }\n\n  /**\n   * Patches the state with provided partial state.\n   *\n   * @param partialStateOrUpdaterFn a partial state or a partial updater\n   * function that accepts the state and returns the partial state.\n   * @throws Error if the state is not initialized.\n   */\n  patchState(\n    partialStateOrUpdaterFn:\n      | Partial<T>\n      | Observable<Partial<T>>\n      | ((state: T) => Partial<T>)\n  ): void {\n    const patchedState =\n      typeof partialStateOrUpdaterFn === 'function'\n        ? partialStateOrUpdaterFn(this.get())\n        : partialStateOrUpdaterFn;\n\n    this.updater((state, partialState: Partial<T>) => ({\n      ...state,\n      ...partialState,\n    }))(patchedState);\n  }\n\n  protected get(): T;\n  protected get<R>(projector: (s: T) => R): R;\n  protected get<R>(projector?: (s: T) => R): R | T {\n    this.assertStateIsInitialized();\n    let value: R | T;\n\n    this.stateSubject$.pipe(take(1)).subscribe((state) => {\n      value = projector ? projector(state) : state;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return value!;\n  }\n\n  /**\n   * Creates a selector.\n   *\n   * @param projector A pure projection function that takes the current state and\n   *   returns some new slice/projection of that state.\n   * @param config SelectConfig that changes the behavior of selector, including\n   *   the debouncing of the values until the state is settled.\n   * @return An observable of the projector results.\n   */\n  select<Result>(\n    projector: (s: T) => Result,\n    config?: SelectConfig\n  ): Observable<Result>;\n  select<SelectorsObject extends Record<string, Observable<unknown>>>(\n    selectorsObject: SelectorsObject,\n    config?: SelectConfig\n  ): Observable<{\n    [K in keyof SelectorsObject]: ObservedValueOf<SelectorsObject[K]>;\n  }>;\n  select<Selectors extends Observable<unknown>[], Result>(\n    ...selectorsWithProjector: [\n      ...selectors: Selectors,\n      projector: Projector<Selectors, Result>\n    ]\n  ): Observable<Result>;\n  select<Selectors extends Observable<unknown>[], Result>(\n    ...selectorsWithProjectorAndConfig: [\n      ...selectors: Selectors,\n      projector: Projector<Selectors, Result>,\n      config: SelectConfig\n    ]\n  ): Observable<Result>;\n  select<\n    Selectors extends Array<\n      Observable<unknown> | SelectConfig | ProjectorFn | SelectorsObject\n    >,\n    Result,\n    ProjectorFn extends (...a: unknown[]) => Result,\n    SelectorsObject extends Record<string, Observable<unknown>>\n  >(...args: Selectors): Observable<Result> {\n    const { observablesOrSelectorsObject, projector, config } =\n      processSelectorArgs<Selectors, Result, ProjectorFn, SelectorsObject>(\n        args\n      );\n\n    const source$ = hasProjectFnOnly(observablesOrSelectorsObject, projector)\n      ? this.stateSubject$\n      : combineLatest(observablesOrSelectorsObject as any);\n\n    return source$.pipe(\n      config.debounce ? debounceSync() : noopOperator(),\n      (projector\n        ? map((projectorArgs) =>\n            // projectorArgs could be an Array in case where the entire state is an Array, so adding this check\n            (observablesOrSelectorsObject as Observable<unknown>[]).length >\n              0 && Array.isArray(projectorArgs)\n              ? projector(...projectorArgs)\n              : projector(projectorArgs)\n          )\n        : noopOperator()) as () => Observable<Result>,\n      distinctUntilChanged(),\n      shareReplay({\n        refCount: true,\n        bufferSize: 1,\n      }),\n      takeUntil(this.destroy$)\n    );\n  }\n\n  /**\n   * Creates a signal from the provided state projector function.\n   */\n  selectSignal<Result>(\n    projector: (state: T) => Result,\n    options?: SelectSignalOptions<Result>\n  ): Signal<Result>;\n  /**\n   * Creates a signal by combining provided signals.\n   */\n  selectSignal<Signals extends Signal<unknown>[], Result>(\n    ...args: [...signals: Signals, projector: SignalsProjector<Signals, Result>]\n  ): Signal<Result>;\n  /**\n   * Creates a signal by combining provided signals.\n   */\n  selectSignal<Signals extends Signal<unknown>[], Result>(\n    ...args: [\n      ...signals: Signals,\n      projector: SignalsProjector<Signals, Result>,\n      options: SelectSignalOptions<Result>\n    ]\n  ): Signal<Result>;\n  selectSignal(\n    ...args:\n      | [(state: T) => unknown, SelectSignalOptions<unknown>?]\n      | [\n          ...signals: Signal<unknown>[],\n          projector: (...values: unknown[]) => unknown\n        ]\n      | [\n          ...signals: Signal<unknown>[],\n          projector: (...values: unknown[]) => unknown,\n          options: SelectSignalOptions<unknown>\n        ]\n  ): Signal<unknown> {\n    const selectSignalArgs = [...args];\n    const defaultEqualityFn: ValueEqualityFn<unknown> = (previous, current) =>\n      previous === current;\n\n    const options: CreateComputedOptions<unknown> =\n      typeof selectSignalArgs[args.length - 1] === 'object'\n        ? {\n            equal:\n              (selectSignalArgs.pop() as SelectSignalOptions<unknown>).equal ||\n              defaultEqualityFn,\n          }\n        : { equal: defaultEqualityFn };\n    const projector = selectSignalArgs.pop() as (\n      ...values: unknown[]\n    ) => unknown;\n    const signals = selectSignalArgs as Signal<unknown>[];\n\n    const computation =\n      signals.length === 0\n        ? () => projector(this.state())\n        : () => {\n            const values = signals.map((signal) => signal());\n            return projector(...values);\n          };\n\n    return computed(computation, options);\n  }\n\n  /**\n   * Creates an effect.\n   *\n   * This effect is subscribed to throughout the lifecycle of the ComponentStore.\n   * @param generator A function that takes an origin Observable input and\n   *     returns an Observable. The Observable that is returned will be\n   *     subscribed to for the life of the component.\n   * @return A function that, when called, will trigger the origin Observable.\n   */\n  effect<\n    // This type quickly became part of effect 'API'\n    ProvidedType = void,\n    // The actual origin$ type, which could be unknown, when not specified\n    OriginType extends\n      | Observable<ProvidedType>\n      | unknown = Observable<ProvidedType>,\n    // Unwrapped actual type of the origin$ Observable, after default was applied\n    ObservableType = OriginType extends Observable<infer A> ? A : never,\n    // Return either an optional callback or a function requiring specific types as inputs\n    ReturnType = ProvidedType | ObservableType extends void\n      ? (\n          observableOrValue?: ObservableType | Observable<ObservableType>\n        ) => Subscription\n      : (\n          observableOrValue: ObservableType | Observable<ObservableType>\n        ) => Subscription\n  >(generator: (origin$: OriginType) => Observable<unknown>): ReturnType {\n    const origin$ = new Subject<ObservableType>();\n    generator(origin$ as OriginType)\n      // tied to the lifecycle 👇 of ComponentStore\n      .pipe(takeUntil(this.destroy$))\n      .subscribe();\n\n    return ((\n      observableOrValue?: ObservableType | Observable<ObservableType>\n    ): Subscription => {\n      const observable$ = isObservable(observableOrValue)\n        ? observableOrValue\n        : of(observableOrValue);\n      return observable$.pipe(takeUntil(this.destroy$)).subscribe((value) => {\n        // any new 👇 value is pushed into a stream\n        origin$.next(value as ObservableType);\n      });\n    }) as unknown as ReturnType;\n  }\n\n  /**\n   * Used to check if lifecycle hooks are defined\n   * but not used with provideComponentStore()\n   */\n  private checkProviderForHooks() {\n    asapScheduler.schedule(() => {\n      if (\n        isDevMode() &&\n        (isOnStoreInitDefined(this) || isOnStateInitDefined(this)) &&\n        !this.ɵhasProvider\n      ) {\n        const warnings = [\n          isOnStoreInitDefined(this) ? 'OnStoreInit' : '',\n          isOnStateInitDefined(this) ? 'OnStateInit' : '',\n        ].filter((defined) => defined);\n\n        console.warn(\n          `@ngrx/component-store: ${\n            this.constructor.name\n          } has the ${warnings.join(' and ')} ` +\n            'lifecycle hook(s) implemented without being provided using the ' +\n            `provideComponentStore(${this.constructor.name}) function. ` +\n            `To resolve this, provide the component store via provideComponentStore(${this.constructor.name})`\n        );\n      }\n    });\n  }\n\n  private assertStateIsInitialized(): void {\n    if (!this.isInitialized) {\n      throw new Error(\n        `${this.constructor.name} has not been initialized yet. ` +\n          `Please make sure it is initialized before updating/getting.`\n      );\n    }\n  }\n}\n\nfunction processSelectorArgs<\n  Selectors extends Array<\n    Observable<unknown> | SelectConfig | ProjectorFn | SelectorsObject\n  >,\n  Result,\n  ProjectorFn extends (...a: unknown[]) => Result,\n  SelectorsObject extends Record<string, Observable<unknown>>\n>(\n  args: Selectors\n):\n  | {\n      observablesOrSelectorsObject: Observable<unknown>[];\n      projector: ProjectorFn;\n      config: Required<SelectConfig>;\n    }\n  | {\n      observablesOrSelectorsObject: SelectorsObject;\n      projector: undefined;\n      config: Required<SelectConfig>;\n    } {\n  const selectorArgs = Array.from(args);\n  // Assign default values.\n  let config: Required<SelectConfig> = { debounce: false };\n\n  // Last argument is either config or projector or selectorsObject\n  if (isSelectConfig(selectorArgs[selectorArgs.length - 1])) {\n    config = { ...config, ...selectorArgs.pop() };\n  }\n\n  // At this point selectorArgs is either projector, selectors with projector or selectorsObject\n  if (selectorArgs.length === 1 && typeof selectorArgs[0] !== 'function') {\n    // this is a selectorsObject\n    return {\n      observablesOrSelectorsObject: selectorArgs[0] as SelectorsObject,\n      projector: undefined,\n      config,\n    };\n  }\n\n  const projector = selectorArgs.pop() as ProjectorFn;\n\n  // The Observables to combine, if there are any left.\n  const observables = selectorArgs as Observable<unknown>[];\n  return {\n    observablesOrSelectorsObject: observables,\n    projector,\n    config,\n  };\n}\n\nfunction isSelectConfig(arg: SelectConfig | unknown): arg is SelectConfig {\n  return typeof (arg as SelectConfig).debounce !== 'undefined';\n}\n\nfunction hasProjectFnOnly(\n  observablesOrSelectorsObject: unknown[] | Record<string, unknown>,\n  projector: unknown\n) {\n  return (\n    Array.isArray(observablesOrSelectorsObject) &&\n    observablesOrSelectorsObject.length === 0 &&\n    projector\n  );\n}\n\nfunction noopOperator(): <T>(source$: Observable<T>) => typeof source$ {\n  return (source$) => source$;\n}\n","import { EMPTY, Observable } from 'rxjs';\nimport { catchError, finalize, tap } from 'rxjs/operators';\n\ntype TapResponseObserver<T, E> = {\n  next: (value: T) => void;\n  error: (error: E) => void;\n  complete?: () => void;\n  finalize?: () => void;\n};\n\nexport function tapResponse<T, E = unknown>(\n  observer: TapResponseObserver<T, E>\n): (source$: Observable<T>) => Observable<T>;\nexport function tapResponse<T, E = unknown>(\n  next: (value: T) => void,\n  error: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T>;\n/**\n * Handles the response in ComponentStore effects in a safe way, without\n * additional boilerplate. It enforces that the error case is handled and\n * that the effect would still be running should an error occur.\n *\n * Takes optional callbacks for `complete` and `finalize`.\n *\n * @usageNotes\n *\n * ```ts\n * readonly dismissAlert = this.effect<Alert>((alert$) => {\n *   return alert$.pipe(\n *     concatMap(\n *       (alert) => this.alertsService.dismissAlert(alert).pipe(\n *         tapResponse(\n *           (dismissedAlert) => this.alertDismissed(dismissedAlert),\n *           (error: { message: string }) => this.logError(error.message)\n *         )\n *       )\n *     )\n *   );\n * });\n *\n * readonly loadUsers = this.effect<void>((trigger$) => {\n *   return trigger$.pipe(\n *     tap(() => this.patchState({ loading: true })),\n *     exhaustMap(() =>\n *       this.usersService.getAll().pipe(\n *         tapResponse({\n *           next: (users) => this.patchState({ users }),\n *           error: (error: HttpErrorResponse) => this.logError(error.message),\n *           finalize: () => this.patchState({ loading: false }),\n *         })\n *       )\n *     )\n *   );\n * });\n * ```\n */\nexport function tapResponse<T, E>(\n  observerOrNext: TapResponseObserver<T, E> | ((value: T) => void),\n  error?: (error: E) => void,\n  complete?: () => void\n): (source$: Observable<T>) => Observable<T> {\n  const observer: TapResponseObserver<T, E> =\n    typeof observerOrNext === 'function'\n      ? {\n          next: observerOrNext,\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          error: error!,\n          complete,\n        }\n      : observerOrNext;\n\n  return (source) =>\n    source.pipe(\n      tap({ next: observer.next, complete: observer.complete }),\n      catchError((error) => {\n        observer.error(error);\n        return EMPTY;\n      }),\n      observer.finalize ? finalize(observer.finalize) : (source$) => source$\n    );\n}\n","/**\n * DO NOT EDIT\n *\n * This file is automatically generated at build\n */\n\nexport * from './public_api';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}